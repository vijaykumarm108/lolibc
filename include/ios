/*
 * Copyright © 2012, MuThink Inc, All rights reserved.
 * http://www.muthink.com
 * Copying and distribution of this product is forbidden without direct permission from MuThink Inc.
 */
#pragma once

#include "lo_utypes.h"

namespace std {

class file_exception;

#ifdef WIN32
#define endl	"\r\n"
#else
const char endl = '\n';		///< End of line character.
#endif
const char ends = '\0';		///< End of string character.

/// Defines types and constants used by all stream classes.
class ios_base {
public:
    /// Used to set parameters for stringstreams
    enum fmtflags {
	boolalpha	= (1 << 0),	///< Boolean values printed as text.
	dec		= (1 << 1),	///< Decimal number output.
	fixed		= (1 << 2),	///< Fixed-point float output.
	hex		= (1 << 3),	///< Hexadecimal number output.
	internal	= (1 << 4),
	left		= (1 << 5),	///< Left alignment.
	oct		= (1 << 6),	///< Octal number output.
	right		= (1 << 7),	///< Right alignment.
	scientific	= (1 << 8),	///< Scientific float format.
	showbase	= (1 << 9),	///< Add 0x or 0 prefixes on hex and octal numbers.
	showpoint	= (1 << 10),	///< Print decimal point.
	showpos		= (1 << 11),
	skipws		= (1 << 12),	///< Skip whitespace when reading.
	unitbuf		= (1 << 13),
	uppercase	= (1 << 14),
	adjustfield	= (1 << 15),
	basefield	= (1 << 16),
	floatfield	= (1 << 17)
    };
    /// For file-based streams, specifies fd mode.
    enum openmode_bits {
	in	= (1 << 0),
	out	= (1 << 1),
	app	= (1 << 2),
	ate	= (1 << 3),
	binary	= (1 << 4),
	trunc	= (1 << 5),
	#ifndef DOXYGEN_SHOULD_SKIP_THIS
	nonblock= (1 << 6),
	nocreate= (1 << 7),
	noctty	= (1 << 8),
	nombits	= 9
	#endif
    };
    /// Seek directions, equivalent to SEEK_SET, SEEK_CUR, and SEEK_END.
    enum seekdir {
	beg,
	cur,
	end
    };
    /// I/O state bitmasks.
    enum iostate_bits {
	goodbit	= 0,
	badbit	= (1 << 0),
	eofbit	= (1 << 1),
	failbit	= (1 << 2),
	#ifndef DOXYGEN_SHOULD_SKIP_THIS
	nbadbits = 3,
	allbadbits = 0x7
	#endif
    };

    typedef uint32_t		openmode;	///< Holds openmode_bits.
    typedef uint32_t		iostate;	///< Holds iostate_bits for a file stream.
    typedef file_exception	failure;	///< Thrown by fstream on errors.

    static const char c_DefaultDelimiters [16];	///< Default word delimiters for stringstreams.
public:
    inline		ios_base (void)			: m_State (goodbit), m_Exceptions (allbadbits) {}
    inline iostate	rdstate (void) const		{ return (m_State); }
    inline bool		bad (void) const		{ return (rdstate() & badbit); }
    inline bool		good (void) const		{ return (rdstate() == goodbit); }
    inline bool		fail (void) const		{ return (rdstate() & (badbit | failbit)) != 0; }
    inline bool		eof (void) const		{ return (rdstate() & eofbit) != 0; }
    inline bool		operator! (void) const		{ return (fail()); }
    inline		operator void* (void) const	{ return ((void*)(!fail())); }
    inline void		clear (iostate v = goodbit)	{ m_State = v; }
    inline void		setstate (iostate v)		{ m_State |= v; }
    inline iostate	exceptions (void) const		{ return (m_Exceptions); }
    inline iostate	exceptions (iostate v)		{ return (m_Exceptions = v); }
protected:
    inline bool		set_and_throw (iostate v)	{ setstate(v); return (exceptions() & v) != 0; }
    void		overrun (const char* op, const char* type, uint32_t n, uint32_t p, uint32_t rem);
private:
    uint16_t		m_State;	///< Open state, using ios::iostate_bits.
    uint16_t		m_Exceptions;	///< Exception flags, using ios::iostate_bits.
};

class ios : public ios_base {
public:
	/// \brief Stream functor to allow inline align() calls.
	///
	/// Example: os << ios::align(sizeof(uint16_t));
	///
	class align {
	public:
		inline explicit		align (size_t grain = c_DefaultAlignment) : m_Grain(grain) {}
		inline istream&		apply (istream& is) const { is.align (m_Grain); return (is); }
		inline ostream&		apply (ostream& os) const { os.align (m_Grain); return (os); }
		inline void		read (istream& is) const  { apply (is); }
		inline void		write (ostream& os) const { apply (os); }
		inline size_t		stream_size (void) const  { return (m_Grain - 1); }
	private:
		const size_t		m_Grain;
	};

	/// \ingroup StreamFunctors
	/// \brief Stream functor to allow type-based alignment.
	template <typename T>
	class talign : public align {
	public:
		inline explicit		talign (void) : align (alignof (NullValue<T>())) {}
	};

	/// \brief Stream functor to allow inline skip() calls.
	///
	/// Example: os << ios::skip(sizeof(uint16_t));
	///
	class skip {
	public:
		inline explicit 	skip (size_t nBytes) : m_nBytes(nBytes) {}
		inline istream&		apply (istream& is) const { is.skip (m_nBytes); return (is); }
		inline ostream&		apply (ostream& os) const { os.skip (m_nBytes); return (os); }
		inline void		read (istream& is) const  { apply (is); }
		inline void		write (ostream& os) const { apply (os); }
		inline size_t		stream_size (void) const  { return (m_nBytes); }
	private:
		const size_t		m_nBytes;
	};

	/// \brief Stream functor to allow inline set_width() calls.
	///
	/// Example: os << ios::width(15);
	///
	class width {
	public:
		inline explicit		width (size_t nBytes) : m_nBytes(nBytes) {}
		inline ostringstream&	apply (ostringstream& os) const { os.set_width ((uint16_t)m_nBytes); return (os); }
		inline void		text_write (ostringstream& os) const { apply (os); }
	private:
		const size_t		m_nBytes;
	};

	/// \brief Stream functor to allow inline set_base() calls.
	///
	/// Example: os << ios::base(15);
	///
	class base {
	public:
		inline explicit		base (size_t n) : m_Base(n) {}
		inline ostringstream&	apply (ostringstream& os) const { os.set_base ((uint16_t)m_Base); return (os); }
		inline void		text_write (ostringstream& os) const { apply (os); }
	private:
		const size_t		m_Base;
	};
};

} // namespace std


CAST_STREAMABLE(lo::std::ios::fmtflags, uint32_t)
NUMERIC_LIMITS(lo::std::ios::fmtflags, lo::std::ios::boolalpha, lo::std::ios::floatfield, false, true, true)
